# User M.hack3r@yahoo.com
# Date 1304358098 -14400
# Node ID e93ad48786af3fd53358b6e43f0de523b838b5c2
# Parent  4a53fbdd1bb43d639ee3cff1f04dbc872a019837
@AC2 Updated by M.Hack3r@Yahoo.com

diff --git a/src/server/game/Entities/Player/Player.cpp b/src/server/game/Entities/Player/Player.cpp
index 24aa215..f7cf887 100755
--- a/src/server/game/Entities/Player/Player.cpp
+++ b/src/server/game/Entities/Player/Player.cpp
@@ -752,6 +752,26 @@ Player::Player (WorldSession *session): Unit(), m_achievementMgr(this), m_reputa
     rest_type=REST_TYPE_NO;
     ////////////////////Rest System/////////////////////
 
+    // movement anticheat
+    m_anti_LastClientTime  = 0;          // last movement client time
+    m_anti_LastServerTime  = 0;          // last movement server time
+    m_anti_DeltaClientTime = 0;          // client side session time
+    m_anti_DeltaServerTime = 0;          // server side session time
+    m_anti_MistimingCount  = 0;          // mistiming count
+
+    m_anti_LastSpeedChangeTime = 0;      // last speed change time
+
+    m_anti_Last_HSpeed =  7.0f;          // horizontal speed, default RUN speed
+    m_anti_Last_VSpeed = -2.3f;          // vertical speed, default max jump height
+
+    m_anti_TeleToPlane_Count = 0;        // Teleport To Plane alarm counter
+
+    m_anti_AlarmCount = 0;               // alarm counter
+
+    m_anti_JumpCount = 0;                // Jump already began, anti air jump check
+    m_anti_JumpBaseZ = 0;                // Z coord before jump (AntiGrav)
+    // end movement anticheat
+
     m_mailsLoaded = false;
     m_mailsUpdated = false;
     unReadMails = 0;
@@ -2143,6 +2163,7 @@ bool Player::TeleportTo(uint32 mapid, float x, float y, float z, float orientati
 
     if ((GetMapId() == mapid && !m_transport) || (GetTransport() && GetMapId() == 628))
     {
+        m_anti_JumpBaseZ = 0;
         //lets reset far teleport flag if it wasn't reset during chained teleports
         SetSemaphoreTeleportFar(false);
         //setup delayed teleport flag
@@ -2291,6 +2312,7 @@ bool Player::TeleportTo(uint32 mapid, float x, float y, float z, float orientati
 
             m_teleport_dest = WorldLocation(mapid, final_x, final_y, final_z, final_o);
             SetFallInformation(0, final_z);
+            m_anti_JumpBaseZ = 0;
             // if the player is saved before worldportack (at logout for example)
             // this will be used instead of the current location in SaveToDB
 
diff --git a/src/server/game/Entities/Player/Player.h b/src/server/game/Entities/Player/Player.h
index 71fe072..e29465b 100755
--- a/src/server/game/Entities/Player/Player.h
+++ b/src/server/game/Entities/Player/Player.h
@@ -2653,6 +2653,27 @@ class Player : public Unit, public GridObject<Player>
         float m_rest_bonus;
         RestType rest_type;
         ////////////////////Rest System/////////////////////
+
+        // movement anticheat
+        time_t m_anti_LastClientTime;           // last movement client time
+        time_t m_anti_LastServerTime;           // last movement server time
+        time_t m_anti_DeltaClientTime;          // client side session time
+        time_t m_anti_DeltaServerTime;          // server side session time
+        uint32 m_anti_MistimingCount;           // mistiming count
+
+        time_t m_anti_LastSpeedChangeTime;      // last speed change time
+
+        float m_anti_Last_HSpeed;               // horizontal speed, default RUN speed
+        float m_anti_Last_VSpeed;               // vertical speed, default max jump height
+
+        uint32 m_anti_TeleToPlane_Count;        // Teleport To Plane alarm counter
+
+        uint64 m_anti_AlarmCount;               // alarm counter
+
+        uint16 m_anti_JumpCount;                // Jump already began, anti air jump check
+        float m_anti_JumpBaseZ;                 // Z coord before jump
+        // end movement anticheat
+
         uint32 m_resetTalentsCost;
         time_t m_resetTalentsTime;
         uint32 m_usedTalentCount;
diff --git a/src/server/game/Entities/Unit/Unit.h b/src/server/game/Entities/Unit/Unit.h
index 1d1b34e..13b7de0 100755
--- a/src/server/game/Entities/Unit/Unit.h
+++ b/src/server/game/Entities/Unit/Unit.h
@@ -2085,6 +2085,7 @@ class Unit : public WorldObject
     protected:
         explicit Unit ();
 
+        GameObject * m_temp_transport;
         UnitAI *i_AI, *i_disabledAI;
 
         void _UpdateSpells(uint32 time);
diff --git a/src/server/game/Globals/ObjectMgr.cpp b/src/server/game/Globals/ObjectMgr.cpp
index 721dd2a..9699c3f 100755
--- a/src/server/game/Globals/ObjectMgr.cpp
+++ b/src/server/game/Globals/ObjectMgr.cpp
@@ -6224,7 +6224,8 @@ void ObjectMgr::LoadAreaTriggerScripts()
     sLog->outString();
 }
 
-uint32 ObjectMgr::GetNearestTaxiNode(float x, float y, float z, uint32 mapid, uint32 team)
+// use searched_node for search some known node
+uint32 ObjectMgr::GetNearestTaxiNode(float x, float y, float z, uint32 mapid, uint32 team, uint32 searched_node)
 {
     bool found = false;
     float dist = 10000;
@@ -6234,7 +6235,18 @@ uint32 ObjectMgr::GetNearestTaxiNode(float x, float y, float z, uint32 mapid, ui
     {
         TaxiNodesEntry const* node = sTaxiNodesStore.LookupEntry(i);
 
-        if (!node || node->map_id != mapid || (!node->MountCreatureID[team == ALLIANCE ? 1 : 0] && node->MountCreatureID[0] != 32981)) // dk flight
+        if (!node || node->map_id != mapid) continue;
+
+        const float dist2 = pow(node->x - x, 2) + pow(node->y - y, 2) + pow(node->z - z, 2);
+
+        if (searched_node != 0 && i == searched_node)
+        {
+            id = i;
+            dist = dist2;
+            break;
+        }
+
+        if (!node->MountCreatureID[team == ALLIANCE ? 1 : 0] && node->MountCreatureID[0] != 32981) // dk flight
             continue;
 
         uint8  field   = (uint8)((i - 1) / 32);
@@ -6244,7 +6256,7 @@ uint32 ObjectMgr::GetNearestTaxiNode(float x, float y, float z, uint32 mapid, ui
         if ((sTaxiNodesMask[field] & submask) == 0)
             continue;
 
-        float dist2 = (node->x - x)*(node->x - x)+(node->y - y)*(node->y - y)+(node->z - z)*(node->z - z);
+        //float dist2 = (node->x - x)*(node->x - x)+(node->y - y)*(node->y - y)+(node->z - z)*(node->z - z);
         if (found)
         {
             if (dist2 < dist)
@@ -6261,6 +6273,9 @@ uint32 ObjectMgr::GetNearestTaxiNode(float x, float y, float z, uint32 mapid, ui
         }
     }
 
+    // movement anticheat fix
+    if (dist > 3600) id = 0;
+    // movement anticheat fix
     return id;
 }
 
diff --git a/src/server/game/Globals/ObjectMgr.h b/src/server/game/Globals/ObjectMgr.h
index c4a5dbb..bf42034 100755
--- a/src/server/game/Globals/ObjectMgr.h
+++ b/src/server/game/Globals/ObjectMgr.h
@@ -704,7 +704,7 @@ class ObjectMgr
         uint32 GetPlayerAccountIdByGUID(const uint64 &guid) const;
         uint32 GetPlayerAccountIdByPlayerName(const std::string& name) const;
 
-        uint32 GetNearestTaxiNode(float x, float y, float z, uint32 mapid, uint32 team);
+        uint32 GetNearestTaxiNode(float x, float y, float z, uint32 mapid, uint32 team, uint32 searched_node);
         void GetTaxiPath(uint32 source, uint32 destination, uint32 &path, uint32 &cost);
         uint32 GetTaxiMountDisplayId(uint32 id, uint32 team, bool allowed_alt_team = false);
 
diff --git a/src/server/game/Server/Protocol/Handlers/MovementHandler.cpp b/src/server/game/Server/Protocol/Handlers/MovementHandler.cpp
index 30b1dc7..3334d7d 100755
--- a/src/server/game/Server/Protocol/Handlers/MovementHandler.cpp
+++ b/src/server/game/Server/Protocol/Handlers/MovementHandler.cpp
@@ -30,6 +30,12 @@
 #include "WaypointMovementGenerator.h"
 #include "InstanceSaveMgr.h"
 #include "ObjectMgr.h"
+#include "World.h"
+
+// Movement anticheat defines
+//#define ANTICHEAT_DEBUG
+#define ANTICHEAT_EXCEPTION_INFO
+// End Movement anticheat defines
 
 void WorldSession::HandleMoveWorldportAckOpcode(WorldPacket & /*recv_data*/)
 {
@@ -250,6 +256,12 @@ void WorldSession::HandleMovementOpcodes(WorldPacket & recv_data)
     ASSERT(mover != NULL);                                  // there must always be a mover
 
     Player *plMover = mover->GetTypeId() == TYPEID_PLAYER ? (Player*)mover : NULL;
+    Vehicle *vehMover = mover->GetVehicleKit();
+    if (vehMover)
+        if (mover->HasFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_PLAYER_CONTROLLED))
+            if (Unit *charmer = mover->GetCharmer())
+                if (charmer->GetTypeId() == TYPEID_PLAYER)
+                    plMover = (Player*)charmer;
 
     // ignore, waiting processing in WorldSession::HandleMoveWorldportAckOpcode and WorldSession::HandleMoveTeleportAck
     if (plMover && plMover->IsBeingTeleported())
@@ -298,7 +310,7 @@ void WorldSession::HandleMovementOpcodes(WorldPacket & recv_data)
         }
 
         // if we boarded a transport, add us to it
-        if (plMover && !plMover->GetTransport())
+        if (plMover && !plMover->m_transport && !plMover->m_temp_transport)
         {
             // elevators also cause the client to send MOVEMENTFLAG_ONTRANSPORT - just unmount if the guid can be found in the transport list
             for (MapManager::TransportSet::const_iterator iter = sMapMgr->m_Transports.begin(); iter != sMapMgr->m_Transports.end(); ++iter)
@@ -310,27 +322,41 @@ void WorldSession::HandleMovementOpcodes(WorldPacket & recv_data)
                     break;
                 }
             }
+            if (!plMover->m_transport)
+                if (Map *tempMap = mover->GetMap())
+                    if (GameObject *tempTransport = tempMap->GetGameObject(movementInfo.t_guid))
+                        if (tempTransport->IsTransport())
+                            plMover->m_temp_transport = tempTransport;
         }
 
-        if (!mover->GetTransport() && !mover->GetVehicle())
+        if ((!plMover && !mover->GetTransport() && !mover->GetVehicle()) || (plMover && !plMover->m_vehicle && !plMover->m_transport && !plMover->m_temp_transport)) // Not sure if the first part is needed. Just added it for verbosity.
         {
             GameObject *go = mover->GetMap()->GetGameObject(movementInfo.t_guid);
             if (!go || go->GetGoType() != GAMEOBJECT_TYPE_TRANSPORT)
                 movementInfo.flags &= ~MOVEMENTFLAG_ONTRANSPORT;
         }
     }
-    else if (plMover && plMover->GetTransport())                // if we were on a transport, leave
+    else if (plMover && (plMover->m_transport || plMover->m_temp_transport)) // if we were on a transport, leave
     {
-        plMover->m_transport->RemovePassenger(plMover);
-        plMover->m_transport = NULL;
-        movementInfo.t_pos.Relocate(0.0f, 0.0f, 0.0f, 0.0f);
+        if (plMover->m_transport)
+        {
+            plMover->m_transport->RemovePassenger(plMover);
+            plMover->m_transport = NULL;
+        }
+        plMover->m_temp_transport = NULL;        movementInfo.t_pos.Relocate(0.0f, 0.0f, 0.0f, 0.0f);
         movementInfo.t_time = 0;
         movementInfo.t_seat = -1;
     }
 
     // fall damage generation (ignore in flight case that can be triggered also at lags in moment teleportation to another map).
     if (opcode == MSG_MOVE_FALL_LAND && plMover && !plMover->isInFlight())
-        plMover->HandleFall(movementInfo);
+    {
+        // movement anticheat
+        plMover->m_anti_JumpCount = 0;
+        plMover->m_anti_JumpBaseZ = 0;
+        if (!vehMover)
+            plMover->HandleFall(movementInfo);
+    }
 
     if (plMover && ((movementInfo.flags & MOVEMENTFLAG_SWIMMING) != 0) != plMover->IsInWater())
     {
@@ -339,55 +365,402 @@ void WorldSession::HandleMovementOpcodes(WorldPacket & recv_data)
     }
 
     /*----------------------*/
+    // begin anti cheat
+    bool check_passed = true;
+    #ifdef ANTICHEAT_DEBUG
+    sLog.outBasic("AC2-%s > time: %d fall-time: %d | xyzo: %f, %f, %fo(%f) flags[%X] opcode[%s] | transport (xyzo): %f, %f, %fo(%f)",
+        plMover->GetName(), movementInfo.time, movementInfo.fallTime, movementInfo.x, movementInfo.y, movementInfo.z, movementInfo.o,
+        movementInfo.flags, LookupOpcodeName(opcode), movementInfo.t_x, movementInfo.t_y, movementInfo.t_z, movementInfo.t_o);
+    sLog.outBasic("AC2-%s Transport > GUID: (low)%d - (high)%d",
+        plMover->GetName(), GUID_LOPART(movementInfo.t_guid), GUID_HIPART(movementInfo.t_guid));
+    #endif
+ 
+    if (plMover)
+    {
+        if (World::GetEnableMvAnticheat() && !plMover->GetCharmerOrOwnerPlayerOrPlayerItself()->isGameMaster() && (World::GetDisableMvAnticheat_Vehicles() && !plMover->GetCharmerOrOwnerPlayerOrPlayerItself()->GetVehicle()))
+        {
+            // calc time deltas
+            int32 cClientTimeDelta = 1500;
+            if (plMover->m_anti_LastClientTime != 0)
+            {
+                cClientTimeDelta = movementInfo.time - plMover->m_anti_LastClientTime;
+                plMover->m_anti_DeltaClientTime += cClientTimeDelta;
+                plMover->m_anti_LastClientTime = movementInfo.time;
+            }
+            else
+                plMover->m_anti_LastClientTime = movementInfo.time;
 
-    /* process position-change */
-    WorldPacket data(opcode, recv_data.size());
-    movementInfo.time = getMSTime();
-    movementInfo.guid = mover->GetGUID();
-    WriteMovementInfo(&data, &movementInfo);
-    mover->SendMessageToSet(&data, _player);
+            const uint64 cServerTime = getMSTime();
+            uint32 cServerTimeDelta = 1500;
+            if (plMover->m_anti_LastServerTime != 0)
+            {
+                cServerTimeDelta = cServerTime - plMover->m_anti_LastServerTime;
+                plMover->m_anti_DeltaServerTime += cServerTimeDelta;
+                plMover->m_anti_LastServerTime = cServerTime;
+            }
+            else
+                plMover->m_anti_LastServerTime = cServerTime;
 
-    mover->m_movementInfo = movementInfo;
+            // resync times on client login (first 15 sec for heavy areas)
+            if (plMover->m_anti_DeltaServerTime < 15000 && plMover->m_anti_DeltaClientTime < 15000)
+                plMover->m_anti_DeltaClientTime = plMover->m_anti_DeltaServerTime;
 
-    // this is almost never true (not sure why it is sometimes, but it is), normally use mover->IsVehicle()
-    if (mover->GetVehicle())
-    {
-        mover->SetOrientation(movementInfo.pos.GetOrientation());
-        return;
-    }
+            const int32 sync_time = plMover->m_anti_DeltaClientTime - plMover->m_anti_DeltaServerTime;
+
+            #ifdef ANTICHEAT_DEBUG
+            sLog.outBasic("AC2-%s Time > cClientTimeDelta: %d, cServerTime: %d | deltaC: %d - deltaS: %d | SyncTime: %d", plMover->GetName(), cClientTimeDelta, cServerTime, plMover->m_anti_DeltaClientTime, plMover->m_anti_DeltaServerTime, sync_time);
+            #endif
+
+            // mistiming checks
+            const int32 GetMistimingDelta = abs(int32(World::GetMistimingDelta()));
+            if (World::GetEnableMvAnticheat_Mistiming() && sync_time > GetMistimingDelta)
+            {
+                cClientTimeDelta = cServerTimeDelta;
+                ++(plMover->m_anti_MistimingCount);
+
+                const bool bMistimingModulo = plMover->m_anti_MistimingCount % 50 == 0;
+
+                if (bMistimingModulo)
+                {
+                    #ifdef ANTICHEAT_EXCEPTION_INFO
+                    sLog->outError("AC2-%s, mistiming exception #%d, mistiming: %dms", plMover->GetName(), plMover->m_anti_MistimingCount, sync_time);
+                    #endif
+                    check_passed = false;
+                }                   
+                // Tell the player "Sure, you can fly!"
+                {
+                    WorldPacket data(SMSG_MOVE_SET_CAN_FLY, 12);
+                    data.append(plMover->GetPackGUID());
+                    data << uint32(0);
+                    SendPacket(&data);
+                }
+                // Then tell the player "Wait, no, you can't."
+                {
+                    WorldPacket data(SMSG_MOVE_UNSET_CAN_FLY, 12);
+                    data.append(plMover->GetPackGUID());
+                    data << uint32(0);
+                    SendPacket(&data);
+                }
+                //plMover->FallGround(2);
+                         
+                /* Disabled, not passive at all, and apparently causing crashes:
+                if (plMover->m_anti_MistimingCount > World::GetMistimingAlarms())
+                {
+                    sWorld.SendWorldText(3, strcat("Kicking cheater: ", plMover->GetName()));
+                    KickPlayer();
+                    return;
+                } */ 
+            }
+            // end mistiming checks
+
+            const uint32 curDest = plMover->m_taxi.GetTaxiDestination(); // check taxi flight
+            if (!curDest)
+            {
+                UnitMoveType move_type;
+
+                // calculating section
+                // current speed
+                if (movementInfo.flags & MOVEMENTFLAG_FLYING)
+                    move_type = movementInfo.flags & MOVEMENTFLAG_BACKWARD ? MOVE_FLIGHT_BACK : MOVE_FLIGHT;
+                else if (movementInfo.flags & MOVEMENTFLAG_SWIMMING)
+                    move_type = movementInfo.flags & MOVEMENTFLAG_BACKWARD ? MOVE_SWIM_BACK : MOVE_SWIM;
+                else if (movementInfo.flags & MOVEMENTFLAG_WALKING)
+                    move_type = MOVE_WALK;
+                // hmm... in first time after login player has MOVE_SWIMBACK instead MOVE_WALKBACK
+                else
+                    move_type = movementInfo.flags & MOVEMENTFLAG_BACKWARD ? MOVE_SWIM_BACK : MOVE_RUN;
+
+                const float current_speed = mover->GetSpeed(move_type);
+                // end current speed
+
+                // movement distance
+                const float delta_x = plMover->m_transport || plMover->m_temp_transport ? 0 : plMover->GetPositionX() - movementInfo.pos.GetPositionX();
+                const float delta_y = plMover->m_transport || plMover->m_temp_transport ? 0 : plMover->GetPositionY() - movementInfo.pos.GetPositionY();
+                const float delta_z = plMover->m_transport || plMover->m_temp_transport ? 0 : plMover->GetPositionZ() - movementInfo.pos.GetPositionZ();
+                const float real_delta = plMover->m_transport || plMover->m_temp_transport ? 0 : pow(delta_x, 2) + pow(delta_y, 2);
+                // end movement distance
+
+                const bool no_fly_auras = !(plMover->HasAuraType(SPELL_AURA_FLY) || plMover->HasAuraType(SPELL_AURA_MOD_INCREASE_VEHICLE_FLIGHT_SPEED)
+                    || plMover->HasAuraType(SPELL_AURA_MOD_INCREASE_MOUNTED_FLIGHT_SPEED) || plMover->HasAuraType(SPELL_AURA_MOD_INCREASE_FLIGHT_SPEED)
+                    || plMover->HasAuraType(SPELL_AURA_MOD_MOUNTED_FLIGHT_SPEED_ALWAYS) || plMover->HasAuraType(SPELL_AURA_MOD_FLIGHT_SPEED_NOT_STACK));
+                const bool no_fly_flags = (movementInfo.flags & (MOVEMENTFLAG_CAN_FLY | MOVEMENTFLAG_FLYING)) == 0;
+
+                const bool no_swim_flags = (movementInfo.flags & MOVEMENTFLAG_SWIMMING) == 0;
+                const bool no_swim_in_water = !mover->IsInWater();
+                const bool no_swim_above_water = movementInfo.pos.GetPositionZ()-7.0f >= mover->GetBaseMap()->GetWaterLevel(movementInfo.pos.GetPositionX(),movementInfo.pos.GetPositionY());
+                const bool no_swim_water = no_swim_in_water && no_swim_above_water;
+
+                const bool no_waterwalk_flags = (movementInfo.flags & MOVEMENTFLAG_WATERWALKING) == 0;
+                const bool no_waterwalk_auras = !(plMover->HasAuraType(SPELL_AURA_WATER_WALK) || plMover->HasAuraType(SPELL_AURA_GHOST));
+
+                if (cClientTimeDelta < 0)
+                    cClientTimeDelta = 0;
+                const float time_delta = cClientTimeDelta < 1500 ? float(cClientTimeDelta)/1000.0f : 1.5f; // normalize time - 1.5 second allowed for heavy loaded server
+
+                const float tg_z = (real_delta != 0 && no_fly_auras && no_swim_flags) ? (pow(delta_z, 2) / real_delta) : -99999; // movement distance tangents
+
+                if (current_speed < plMover->m_anti_Last_HSpeed && plMover->m_anti_LastSpeedChangeTime == 0)
+                    plMover->m_anti_LastSpeedChangeTime = movementInfo.time + uint32(floor(((plMover->m_anti_Last_HSpeed / current_speed) * 1500)) + 100); // 100ms above for random fluctuation
+
+                const float allowed_delta = plMover->m_transport || plMover->m_temp_transport ? 2 : // movement distance allowed delta
+                    pow(std::max(current_speed, plMover->m_anti_Last_HSpeed) * time_delta, 2)
+                    + 2                                                                             // minimum allowed delta
+                    + (tg_z > 2.2 ? pow(delta_z, 2)/2.37f : 0);                                     // mountain fall allowed delta
+
+                if (movementInfo.time > plMover->m_anti_LastSpeedChangeTime)
+                {
+                    plMover->m_anti_Last_HSpeed = current_speed;                                    // store current speed
+                    plMover->m_anti_Last_VSpeed = -2.3f;
+                    plMover->m_anti_LastSpeedChangeTime = 0;
+                }
+                // end calculating section
+
+                // AntiGravity (thanks to Meekro)
+                const float JumpHeight = plMover->m_anti_JumpBaseZ - movementInfo.pos.GetPositionZ();
+                if (World::GetEnableMvAnticheat_AntiGravity() && no_fly_auras && no_swim_in_water && plMover->m_anti_JumpBaseZ != 0 && JumpHeight < plMover->m_anti_Last_VSpeed)
+                {
+                    #ifdef ANTICHEAT_EXCEPTION_INFO
+                    sLog->outError("AC2-%s, AntiGravity exception. JumpHeight = %f, Allowed Vertical Speed = %f",
+                        plMover->GetName(), JumpHeight, plMover->m_anti_Last_VSpeed);
+                    #endif
+                    check_passed = false;
+                    // Tell the player "Sure, you can fly!"
+                    {
+                        WorldPacket data(SMSG_MOVE_SET_CAN_FLY, 12);
+                        data.append(plMover->GetPackGUID());
+                        data << uint32(0);
+                        SendPacket(&data);
+                    }
+                    // Then tell the player "Wait, no, you can't."
+                    {
+                        WorldPacket data(SMSG_MOVE_UNSET_CAN_FLY, 12);
+                        data.append(plMover->GetPackGUID());
+                        data << uint32(0);
+                        SendPacket(&data);
+                    }
+                    //plMover->FallGround(2);
+                }
+
+                // multi jump checks
+                if (opcode == MSG_MOVE_JUMP)
+                {
+                    if (no_fly_auras && no_swim_water)
+                    {
+                        if (World::GetEnableMvAnticheat_MultiJump() && plMover->m_anti_JumpCount >= 1)
+                        {
+                            // don't process new jump packet
+                            check_passed = false;
+                            // Tell the player "Sure, you can fly!"
+                            {
+                                WorldPacket data(SMSG_MOVE_SET_CAN_FLY, 12);
+                                data.append(plMover->GetPackGUID());
+                                data << uint32(0);
+                                SendPacket(&data);
+                            }
+                            // Then tell the player "Wait, no, you can't."
+                            {
+                                WorldPacket data(SMSG_MOVE_UNSET_CAN_FLY, 12);
+                                data.append(plMover->GetPackGUID());
+                                data << uint32(0);
+                                SendPacket(&data);
+                            }
+                            //plMover->FallGround(2);
+                            plMover->m_anti_JumpCount = 0;
+                        }
+                        else
+                        {
+                            plMover->m_anti_JumpCount += 1;
+                            plMover->m_anti_JumpBaseZ = movementInfo.pos.GetPositionZ();
+                        }
+                    } else
+                        plMover->m_anti_JumpCount = 0;
+                }
 
-    mover->SetPosition(movementInfo.pos);
+                // speed and teleport hack checks
+                if (real_delta > allowed_delta)
+                {
+                    #ifdef ANTICHEAT_EXCEPTION_INFO
+                        if (real_delta < 4900.0f && World::GetEnableMvAnticheat_Speedhack())
+                        {
+                            sLog->outError("AC2-%s, speed exception | cDelta=%f aDelta=%f | cSpeed=%f lSpeed=%f deltaTime=%f", plMover->GetName(), real_delta, allowed_delta, current_speed, plMover->m_anti_Last_HSpeed, time_delta);
+                            check_passed = false;
+                        }
+                        else if (World::GetEnableMvAnticheat_Teleport())
+                        {
+                            sLog->outError("AC2-%s, teleport exception | cDelta=%f aDelta=%f | cSpeed=%f lSpeed=%f deltaTime=%f", plMover->GetName(), real_delta, allowed_delta, current_speed, plMover->m_anti_Last_HSpeed, time_delta);
+                            check_passed = false;
+                        }
+                    #endif
+                    //plMover->FallGround(2);
+                }
+
+                // mountain hack checks // 1.56f (delta_z < GetPlayer()->m_anti_Last_VSpeed))
+                if (World::GetEnableMvAnticheat_Mountainhack() && delta_z < plMover->m_anti_Last_VSpeed && plMover->m_anti_JumpCount == 0 && tg_z > 2.37f)
+                {
+                    #ifdef ANTICHEAT_EXCEPTION_INFO
+                    sLog->outError("AC2-%s, mountain exception | tg_z=%f", plMover->GetName(), tg_z);
+                    #endif
+                    check_passed = false;
+                }
+ 
+                // Fly hack checks
+                if (World::GetEnableMvAnticheat_Flyhack() && no_fly_auras && !no_fly_flags)
+                {
+                    #ifdef ANTICHEAT_EXCEPTION_INFO // Aura numbers: 201, 206, 207, 208, 209, 211
+                    sLog->outError("AC2-%s, flight exception. {SPELL_AURA_FLY=[%X]} {SPELL_AURA_MOD_INCREASE_MOUNTED_FLIGHT_SPEED=[%X]} {SPELL_AURA_MOD_INCREASE_FLIGHT_SPEED=[%X]} {SPELL_AURA_MOD_MOUNTED_FLIGHT_SPEED_ALWAYS=[%X]} {SPELL_AURA_MOD_FLIGHT_SPEED_NOT_STACK=[%X]} {plMover->GetVehicle()=[%X]}",
+                        plMover->GetName(),
+                        plMover->HasAuraType(SPELL_AURA_FLY), plMover->HasAuraType(SPELL_AURA_MOD_INCREASE_MOUNTED_FLIGHT_SPEED),
+                        plMover->HasAuraType(SPELL_AURA_MOD_INCREASE_FLIGHT_SPEED), plMover->HasAuraType(SPELL_AURA_MOD_MOUNTED_FLIGHT_SPEED_ALWAYS),
+                        plMover->HasAuraType(SPELL_AURA_MOD_FLIGHT_SPEED_NOT_STACK), plMover->GetVehicle());
+                    #endif
+                    check_passed = false;
+                    // Tell the player "Sure, you can fly!"
+                    {
+                        WorldPacket data(SMSG_MOVE_SET_CAN_FLY, 12);
+                        data.append(plMover->GetPackGUID());
+                        data << uint32(0);
+                        SendPacket(&data);
+                    }
+                    // Then tell the player "Wait, no, you can't."
+                    {
+                        WorldPacket data(SMSG_MOVE_UNSET_CAN_FLY, 12);
+                        data.append(plMover->GetPackGUID());
+                        data << uint32(0);
+                        SendPacket(&data);
+                    }
+                    //plMover->FallGround(2);
+                }
 
-    if (plMover)                                            // nothing is charmed, or player charmed
+                // Waterwalk checks
+                if (World::GetEnableMvAnticheat_Waterwalk() && no_waterwalk_auras && !no_waterwalk_flags)
+                {
+                    #ifdef ANTICHEAT_EXCEPTION_INFO
+                    sLog->outError("AC2-%s, waterwalk exception. [%X]{SPELL_AURA_WATER_WALK=[%X]}",
+                        plMover->GetName(), movementInfo.flags, plMover->HasAuraType(SPELL_AURA_WATER_WALK));
+                    #endif
+                    check_passed = false;
+                    // Tell the player "Sure, you can fly!"
+                    {
+                        WorldPacket data(SMSG_MOVE_SET_CAN_FLY, 12);
+                        data.append(plMover->GetPackGUID());
+                        data << uint32(0);
+                        SendPacket(&data);
+                    }
+                    // Then tell the player "Wait, no, you can't."
+                    {
+                        WorldPacket data(SMSG_MOVE_UNSET_CAN_FLY, 12);
+                        data.append(plMover->GetPackGUID());
+                        data << uint32(0);
+                        SendPacket(&data);
+                    }
+                    //plMover->FallGround(2);
+                }
+
+                // Teleport To Plane checks
+                if (World::GetEnableMvAnticheat_TeleportToPlane() && no_swim_in_water && movementInfo.pos.GetPositionZ() < 0.0001f && movementInfo.pos.GetPositionZ() > -0.0001f)
+                {
+                    if (const Map *map = plMover->GetMap())
+                    {
+                        float plane_z = map->GetHeight(movementInfo.pos.GetPositionX(), movementInfo.pos.GetPositionY(), MAX_HEIGHT) - movementInfo.pos.GetPositionZ();
+                        plane_z = (plane_z < -500.0f) ? 0.0f : plane_z; // check holes in height map
+                        if (plane_z > 0.1f || plane_z < -0.1f)
+                        {
+                            #ifdef ANTICHEAT_DEBUG
+                            sLog->outDebug("AC2-%s, teleport to plane exception. plane_z: %f", plMover->GetName(), plane_z);
+                            #endif
+                            #ifdef ANTICHEAT_EXCEPTION_INFO
+                            if (plMover->m_anti_TeleToPlane_Count > World::GetTeleportToPlaneAlarms())
+                            {
+                                sLog->outError("AC2-%s, teleport to plane exception. Exception count: %d", plMover->GetName(), plMover->m_anti_TeleToPlane_Count);
+                                /* Disabled, not passive at all, and apparently causing crashes:
+                                sWorld.SendWorldText(3, strcat("Kicking cheater: ", plMover->GetName()));
+                                KickPlayer();
+                                return; */
+                            }
+                            #endif
+                            ++(plMover->m_anti_TeleToPlane_Count);
+                            check_passed = false;
+                        }
+                    }
+                }
+                else
+                    plMover->m_anti_TeleToPlane_Count = 0;
+            }
+        }
+    }	
+    /* process position-change */
+    if (check_passed)
     {
-        plMover->UpdateFallInformationIfNeed(movementInfo, opcode);
+        WorldPacket data(opcode, recv_data.size());
+        movementInfo.time = getMSTime();
+        movementInfo.guid = mover->GetGUID();
+        WriteMovementInfo(&data, &movementInfo);
+        mover->SendMessageToSet(&data, _player);
+
+        mover->m_movementInfo = movementInfo;
 
-        if (movementInfo.pos.GetPositionZ() < -500.0f)
+        // this is almost never true (not sure why it is sometimes, but it is), normally use mover->IsVehicle()
+        if (mover->GetVehicle())
         {
-            if (!(plMover->InBattleground()
-                && plMover->GetBattleground()
-                && plMover->GetBattleground()->HandlePlayerUnderMap(_player)))
+            mover->SetOrientation(movementInfo.pos.GetOrientation());
+            return;
+        }
+
+        mover->SetPosition(movementInfo.pos);
+
+        if (plMover && !vehMover)                               // nothing is charmed, or player charmed
+        {
+            plMover->UpdateFallInformationIfNeed(movementInfo, opcode);
+
+            if (movementInfo.pos.GetPositionZ() < -500.0f)
             {
-                // NOTE: this is actually called many times while falling
-                // even after the player has been teleported away
-                // TODO: discard movement packets after the player is rooted
-                if (plMover->isAlive())
+                if (!(plMover->InBattleground()
+                    && plMover->GetBattleground()
+                    && plMover->GetBattleground()->HandlePlayerUnderMap(_player)))
                 {
-                    plMover->EnvironmentalDamage(DAMAGE_FALL_TO_VOID, GetPlayer()->GetMaxHealth());
-                    // pl can be alive if GM/etc
-                    if (!plMover->isAlive())
+                    // NOTE: this is actually called many times while falling
+                    // even after the player has been teleported away
+                    // TODO: discard movement packets after the player is rooted
+                    if (plMover->isAlive())
                     {
-                        // change the death state to CORPSE to prevent the death timer from
-                        // starting in the next player update
-                        plMover->KillPlayer();
-                        plMover->BuildPlayerRepop();
+                        plMover->EnvironmentalDamage(DAMAGE_FALL_TO_VOID, GetPlayer()->GetMaxHealth());
+                        // pl can be alive if GM/etc
+                        if (!plMover->isAlive())
+                        {
+                            // change the death state to CORPSE to prevent the death timer from
+                            // starting in the next player update
+                            plMover->KillPlayer();
+                            plMover->BuildPlayerRepop();
+                        }
                     }
-                }
 
-                // cancel the death timer here if started
-                plMover->RepopAtGraveyard();
+                    // cancel the death timer here if started
+                    plMover->RepopAtGraveyard();
+                }
             }
+            // movement anticheat
+            if (plMover->m_anti_AlarmCount > 0)
+            {
+                sLog->outError("AC2-%s produce %d anticheat alarms", plMover->GetName(), plMover->m_anti_AlarmCount);
+                plMover->m_anti_AlarmCount = 0;
+            }
+            // end movement anticheat
+	    }
+    }
+    else if (plMover)
+    {
+        if (plMover->m_transport)
+        {
+            plMover->m_transport->RemovePassenger(plMover);
+            plMover->m_transport = NULL;
         }
+        plMover->m_temp_transport = NULL;
+        ++(plMover->m_anti_AlarmCount);
+        WorldPacket data;
+        plMover->SetUnitMovementFlags(0);
+        plMover->SendTeleportAckPacket();
+        plMover->BuildHeartBeatMsg(&data);
+        plMover->SendMessageToSet(&data, true);
     }
 }
 
@@ -531,6 +904,20 @@ void WorldSession::HandleMoveKnockBackAck(WorldPacket & recv_data)
 
     MovementInfo movementInfo;
     ReadMovementInfo(recv_data, &movementInfo);
+
+    // Save movement flags
+    _player->SetUnitMovementFlags(movementInfo.flags);
+    #ifdef ANTICHEAT_DEBUG
+        sLog->outBasic("%s CMSG_MOVE_KNOCK_BACK_ACK: time: %d, fall time: %d | xyzo: %f,%f,%fo(%f) flags[%X]", GetPlayer()->GetName(), movementInfo.time, movementInfo.fallTime, movementInfo.x, movementInfo.y, movementInfo.z, movementInfo.o, movementInfo.flags);
+        sLog->outBasic("%s CMSG_MOVE_KNOCK_BACK_ACK additional: Vspeed: %f, Hspeed: %f", GetPlayer()->GetName(), movementInfo.j_unk, movementInfo.j_xyspeed);
+    #endif
+
+    _player->m_movementInfo = movementInfo;
+    _player->m_anti_Last_HSpeed = movementInfo.j_xyspeed;
+    _player->m_anti_Last_VSpeed = movementInfo.j_zspeed < 3.2f ? movementInfo.j_zspeed - 1.0f : 3.2f;
+
+    const uint32 dt = (_player->m_anti_Last_VSpeed < 0) ? int(ceil(_player->m_anti_Last_VSpeed/-25)*1000) : int(ceil(_player->m_anti_Last_VSpeed/25)*1000);
+    _player->m_anti_LastSpeedChangeTime = movementInfo.time + dt + 1000;
 }
 
 void WorldSession::HandleMoveHoverAck(WorldPacket& recv_data)
diff --git a/src/server/game/Server/Protocol/Handlers/TaxiHandler.cpp b/src/server/game/Server/Protocol/Handlers/TaxiHandler.cpp
--- a/src/server/game/Server/Protocol/Handlers/TaxiHandler.cpp
+++ b/src/server/game/Server/Protocol/Handlers/TaxiHandler.cpp
@@ -49,7 +49,7 @@
         return;
     }
 
-    uint32 curloc = sObjectMgr->GetNearestTaxiNode(unit->GetPositionX(), unit->GetPositionY(), unit->GetPositionZ(), unit->GetMapId(), GetPlayer()->GetTeam());
+    uint32 curloc = sObjectMgr->GetNearestTaxiNode(unit->GetPositionX(), unit->GetPositionY(), unit->GetPositionZ(), unit->GetMapId(), GetPlayer()->GetTeam(), 0);
 
     // not found nearest
     if (curloc == 0)
@@ -94,7 +94,7 @@
 void WorldSession::SendTaxiMenu(Creature* unit)
 {
     // find current node
-    uint32 curloc = sObjectMgr->GetNearestTaxiNode(unit->GetPositionX(), unit->GetPositionY(), unit->GetPositionZ(), unit->GetMapId(), GetPlayer()->GetTeam());
+    uint32 curloc = sObjectMgr->GetNearestTaxiNode(unit->GetPositionX(), unit->GetPositionY(), unit->GetPositionZ(), unit->GetMapId(), GetPlayer()->GetTeam(), 0);
 
     if (curloc == 0)
         return;
@@ -134,7 +134,7 @@
 bool WorldSession::SendLearnNewTaxiNode(Creature* unit)
 {
     // find current node
-    uint32 curloc = sObjectMgr->GetNearestTaxiNode(unit->GetPositionX(), unit->GetPositionY(), unit->GetPositionZ(), unit->GetMapId(), GetPlayer()->GetTeam());
+    uint32 curloc = sObjectMgr->GetNearestTaxiNode(unit->GetPositionX(), unit->GetPositionY(), unit->GetPositionZ(), unit->GetMapId(), GetPlayer()->GetTeam(), 0);
 
     if (curloc == 0)
         return true;                                        // `true` send to avoid WorldSession::SendTaxiMenu call with one more curlock seartch with same false result.
@@ -203,6 +203,13 @@
     uint64 guid; // used only for proper packet read
     recv_data.readPackGUID(guid);
 
+    // movement anticheat code
+    const Unit *mover = _player->m_mover;
+    const Player *plMover = mover->GetTypeId() == TYPEID_PLAYER ? (Player*)mover : NULL;
+    if (!plMover)
+        return;
+    // end movement anticheat
+
     MovementInfo movementInfo;                              // used only for proper packet read
     ReadMovementInfo(recv_data, &movementInfo);
 
@@ -215,10 +222,75 @@
 
     uint32 curDest = GetPlayer()->m_taxi.GetTaxiDestination();
     if (!curDest)
+    {
+        // movement anticheat code
+        GetPlayer()->SetPosition(movementInfo.pos.GetPositionX(), movementInfo.pos.GetPositionY(), movementInfo.pos.GetPositionZ(), movementInfo.pos.GetOrientation());
+        GetPlayer()->m_movementInfo = movementInfo;
+        GetPlayer()->SetUnitMovementFlags(movementInfo.flags);
+
+        // calc time deltas
+        int32 cClientTimeDelta = 0;
+        if (GetPlayer()->m_anti_LastClientTime != 0)
+        {
+            cClientTimeDelta = movementInfo.time - GetPlayer()->m_anti_LastClientTime;
+            GetPlayer()->m_anti_DeltaClientTime += cClientTimeDelta;
+            GetPlayer()->m_anti_LastClientTime = movementInfo.time;
+        }
+        else
+            GetPlayer()->m_anti_LastClientTime = movementInfo.time;
+
+        const uint64 cServerTime = getMSTime();
+        uint32 cServerTimeDelta = 0;
+        if (GetPlayer()->m_anti_LastServerTime != 0)
+        {
+            cServerTimeDelta = cServerTime - GetPlayer()->m_anti_LastServerTime;
+            GetPlayer()->m_anti_DeltaServerTime += cServerTimeDelta;
+            GetPlayer()->m_anti_LastServerTime = cServerTime;
+        }
+        else
+            GetPlayer()->m_anti_LastServerTime = cServerTime;
+        // end movement anticheat
         return;
+	}
+    // movment anticheat
+    const uint32 curloc = 
+    sObjectMgr->GetNearestTaxiNode(movementInfo.pos.GetPositionX(),movementInfo.pos.GetPositionY(),movementInfo.pos.GetPositionZ(),GetPlayer()->GetMapId(),GetPlayer()->GetTeam(), curDest);
+    // end movement anticheat
 
-    TaxiNodesEntry const* curDestNode = sTaxiNodesStore.LookupEntry(curDest);
+    // sLog.outBasic("AC2-%s > | xyzo: %f,%f,%fo(%f) flags[%X] | curloc: %d | destloc: %d ",
+    // GetPlayer()->GetName(), movementInfo.x, movementInfo.y, movementInfo.z, movementInfo.o,
+    // movementInfo.flags, curloc, curDest);
+     TaxiNodesEntry const* curDestNode = sTaxiNodesStore.LookupEntry(curDest);
+    if (curDestNode && curDestNode->map_id == GetPlayer()->GetMapId())
+        while (GetPlayer()->GetMotionMaster()->GetCurrentMovementGeneratorType() == FLIGHT_MOTION_TYPE)
+            GetPlayer()->GetMotionMaster()->MovementExpired(false);
 
+    // movement anticheat code
+    GetPlayer()->SetPosition(movementInfo.pos.GetPositionX(), movementInfo.pos.GetPositionY(), movementInfo.pos.GetPositionZ(), movementInfo.pos.GetOrientation());
+    GetPlayer()->m_movementInfo = movementInfo;
+    GetPlayer()->SetUnitMovementFlags(movementInfo.flags);
+    // calc time deltas
+    int32 cClientTimeDelta = 0;
+    if (GetPlayer()->m_anti_LastClientTime != 0)
+    {
+        cClientTimeDelta = movementInfo.time - GetPlayer()->m_anti_LastClientTime;
+        GetPlayer()->m_anti_DeltaClientTime += cClientTimeDelta;
+        GetPlayer()->m_anti_LastClientTime = movementInfo.time;
+    }
+    else
+        GetPlayer()->m_anti_LastClientTime = movementInfo.time;
+ 
+    const uint64 cServerTime = getMSTime();
+    uint32 cServerTimeDelta = 0;
+    if (GetPlayer()->m_anti_LastServerTime != 0)
+    {
+        cServerTimeDelta = cServerTime - GetPlayer()->m_anti_LastServerTime;
+        GetPlayer()->m_anti_DeltaServerTime += cServerTimeDelta;
+        GetPlayer()->m_anti_LastServerTime = cServerTime;
+    }
+    else
+        GetPlayer()->m_anti_LastServerTime = cServerTime;
+    // end movement anticheat
     // far teleport case
     if (curDestNode && curDestNode->map_id != GetPlayer()->GetMapId())
     {
@@ -235,6 +307,23 @@
         }
         return;
     }
+    // movement anticheat fix - disallow unmount from taxi
+    if (curloc != curDest)
+    {
+         // current source node for next destination
+        uint32 sourcenode = GetPlayer()->m_taxi.GetTaxiSource();
+        uint16 MountId = sObjectMgr->GetTaxiMountDisplayId(sourcenode, GetPlayer()->GetTeam());
+
+        uint32 path, cost;
+        sObjectMgr->GetTaxiPath(sourcenode, curDest, path, cost);
+
+        if (path && MountId)
+            SendDoFlight(MountId, path, 1);                 // skip start fly node
+        else
+            GetPlayer()->m_taxi.ClearTaxiDestinations();    // clear problematic path and next
+        return;
+    }
+    // end movement anticheat
 
     uint32 destinationnode = GetPlayer()->m_taxi.NextTaxiDestination();
     if (destinationnode > 0)                              // if more destinations to go
diff --git a/src/server/game/World/World.cpp b/src/server/game/World/World.cpp
index e8133eb..0c316c2 100755
--- a/src/server/game/World/World.cpp
+++ b/src/server/game/World/World.cpp
@@ -85,6 +85,22 @@ int32 World::m_visibility_notify_periodOnContinents = DEFAULT_VISIBILITY_NOTIFY_
 int32 World::m_visibility_notify_periodInInstances  = DEFAULT_VISIBILITY_NOTIFY_PERIOD;
 int32 World::m_visibility_notify_periodInBGArenas   = DEFAULT_VISIBILITY_NOTIFY_PERIOD;
 
+// movement anticheat
+bool World::m_EnableMvAnticheat = true;
+uint32 World::m_TeleportToPlaneAlarms = 50;
+uint32 World::m_MistimingAlarms = 200;
+uint32 World::m_MistimingDelta = 15000;
+bool World::m_DisableMvAnticheat_Vehicles = true;
+bool World::m_EnableMvAnticheat_Mistiming = true;
+bool World::m_EnableMvAnticheat_TeleportToPlane = true;
+bool World::m_EnableMvAnticheat_Waterwalk = true;
+bool World::m_EnableMvAnticheat_Flyhack = true;
+bool World::m_EnableMvAnticheat_Mountainhack = true;
+bool World::m_EnableMvAnticheat_Speedhack = true;
+bool World::m_EnableMvAnticheat_Teleport = true;
+bool World::m_EnableMvAnticheat_MultiJump = true;
+bool World::m_EnableMvAnticheat_AntiGravity = true;
+
 /// World constructor
 World::World()
 {
@@ -558,6 +574,51 @@ void World::LoadConfigSettings(bool reload)
         sLog->outError("DurabilityLossChance.Block (%f) must be >=0. Using 0.0 instead.", rate_values[RATE_DURABILITY_LOSS_BLOCK]);
         rate_values[RATE_DURABILITY_LOSS_BLOCK] = 0.0f;
     }
+    // movement anticheat
+    m_EnableMvAnticheat = sConfig->GetBoolDefault("Anticheat.Movement.Enable", true);
+    m_TeleportToPlaneAlarms = sConfig->GetIntDefault("Anticheat.Movement.TeleportToPlaneAlarms", 50);
+    if (m_TeleportToPlaneAlarms < 20)
+    {
+        sLog->outError("Anticheat.Movement.TeleportToPlaneAlarms (%d) must be >= 20. Using 20 instead.", m_TeleportToPlaneAlarms);
+        m_TeleportToPlaneAlarms = 20;
+    }
+    if (m_TeleportToPlaneAlarms > 100)
+    {
+        sLog->outError("Anticheat.Movement.TeleportToPlaneAlarms (%d) must be <= 100. Using 100 instead.", m_TeleportToPlaneAlarms);
+        m_TeleportToPlaneAlarms = 100;
+    }
+    m_MistimingDelta = sConfig->GetIntDefault("Anticheat.Movement.MistimingDelta", 15000);
+    if (m_MistimingDelta < 5000)
+    {
+        sLog->outError("Anticheat.Movement.m_MistimingDelta (%d) must be >= 5000ms. Using 5000ms instead.", m_MistimingDelta);
+        m_MistimingDelta = 5000;
+    }
+    if (m_MistimingDelta > 50000)
+    {
+        sLog->outError("Anticheat.Movement.m_MistimingDelta (%d) must be <= 50000ms. Using 50000ms instead.", m_MistimingDelta);
+        m_MistimingDelta = 50000;
+    }
+    m_MistimingAlarms = sConfig->GetIntDefault("Anticheat.Movement.MistimingAlarms", 200);
+    if (m_MistimingAlarms < 100)
+    {
+        sLog->outError("Anticheat.Movement.MistimingAlarms (%d) must be >= 100. Using 100 instead.", m_MistimingAlarms);
+        m_MistimingAlarms = 100;
+    }
+    if (m_MistimingAlarms > 500)
+    {
+        sLog->outError("Anticheat.Movement.m_MistimingAlarms (%d) must be <= 500. Using 500 instead.", m_MistimingAlarms);
+        m_MistimingAlarms = 500;
+    }
+    m_DisableMvAnticheat_Vehicles = sConfig->GetBoolDefault("Anticheat.Movement.DisableOnVehicles", true);
+    m_EnableMvAnticheat_Mistiming = sConfig->GetBoolDefault("Anticheat.Movement.Mistiming", true);
+    m_EnableMvAnticheat_TeleportToPlane = sConfig->GetBoolDefault("Anticheat.Movement.Type.TeleportToPlane", true);
+    m_EnableMvAnticheat_Waterwalk = sConfig->GetBoolDefault("Anticheat.Movement.Type.Waterwalk", true);
+    m_EnableMvAnticheat_Flyhack = sConfig->GetBoolDefault("Anticheat.Movement.Type.Flyhack", true);
+    m_EnableMvAnticheat_Mountainhack = sConfig->GetBoolDefault("Anticheat.Movement.Type.Mountainhack", true);
+    m_EnableMvAnticheat_Speedhack = sConfig->GetBoolDefault("Anticheat.Movement.Type.Speedhack", true);
+    m_EnableMvAnticheat_Teleport = sConfig->GetBoolDefault("Anticheat.Movement.Type.Teleport", true);
+    m_EnableMvAnticheat_MultiJump = sConfig->GetBoolDefault("Anticheat.Movement.Type.MultiJump", true);
+    m_EnableMvAnticheat_AntiGravity = sConfig->GetBoolDefault("Anticheat.Movement.Type.AntiGravity", true);
     ///- Read other configuration items from the config file
 
     m_bool_configs[CONFIG_DURABILITY_LOSS_IN_PVP] = sConfig->GetBoolDefault("DurabilityLoss.InPvP", false);
diff --git a/src/server/game/World/World.h b/src/server/game/World/World.h
index 5a6f85a..07b633b 100755
--- a/src/server/game/World/World.h
+++ b/src/server/game/World/World.h
@@ -704,6 +704,23 @@ class World
         static int32 GetVisibilityNotifyPeriodInInstances() { return m_visibility_notify_periodInInstances;  }
         static int32 GetVisibilityNotifyPeriodInBGArenas()  { return m_visibility_notify_periodInBGArenas;   }
 
+        // movement anticheat
+        static bool GetEnableMvAnticheat()       { return m_EnableMvAnticheat;     }
+        static uint32 GetTeleportToPlaneAlarms() { return m_TeleportToPlaneAlarms; }
+        static uint32 GetMistimingDelta()        { return m_MistimingDelta;        }
+        static uint32 GetMistimingAlarms()       { return m_MistimingAlarms;       }
+        static bool GetDisableMvAnticheat_Vehicles()       { return m_DisableMvAnticheat_Vehicles;       }
+        static bool GetEnableMvAnticheat_Mistiming()       { return m_EnableMvAnticheat_Mistiming;       }
+        static bool GetEnableMvAnticheat_TeleportToPlane() { return m_EnableMvAnticheat_TeleportToPlane; }
+        static bool GetEnableMvAnticheat_Waterwalk()       { return m_EnableMvAnticheat_Waterwalk;       }
+        static bool GetEnableMvAnticheat_Flyhack()         { return m_EnableMvAnticheat_Flyhack;         }
+        static bool GetEnableMvAnticheat_Mountainhack()    { return m_EnableMvAnticheat_Mountainhack;    }
+        static bool GetEnableMvAnticheat_Speedhack()       { return m_EnableMvAnticheat_Speedhack;       }
+        static bool GetEnableMvAnticheat_Teleport()        { return m_EnableMvAnticheat_Teleport;        }
+        static bool GetEnableMvAnticheat_MultiJump()       { return m_EnableMvAnticheat_MultiJump;       }
+        static bool GetEnableMvAnticheat_AntiGravity()     { return m_EnableMvAnticheat_AntiGravity;     }
+        // end movement anticheat
+
         void ProcessCliCommands();
         void QueueCliCommand(CliCommandHolder* commandHolder) { cliCmdQueue.add(commandHolder); }
 
@@ -796,6 +813,22 @@ class World
         static int32 m_visibility_notify_periodInInstances;
         static int32 m_visibility_notify_periodInBGArenas;
 
+        // movement anticheat enable flag
+        static bool m_EnableMvAnticheat;
+        static uint32 m_TeleportToPlaneAlarms;
+        static uint32 m_MistimingDelta;
+        static uint32 m_MistimingAlarms;
+        static bool m_DisableMvAnticheat_Vehicles;
+        static bool m_EnableMvAnticheat_Mistiming;
+        static bool m_EnableMvAnticheat_TeleportToPlane;
+        static bool m_EnableMvAnticheat_Waterwalk;
+        static bool m_EnableMvAnticheat_Flyhack;
+        static bool m_EnableMvAnticheat_Mountainhack;
+        static bool m_EnableMvAnticheat_Speedhack;
+        static bool m_EnableMvAnticheat_Teleport;
+        static bool m_EnableMvAnticheat_MultiJump;
+        static bool m_EnableMvAnticheat_AntiGravity;
+
         // CLI command holder to be thread safe
         ACE_Based::LockedQueue<CliCommandHolder*, ACE_Thread_Mutex> cliCmdQueue;
 
diff --git a/src/server/worldserver/worldserver.conf.dist b/src/server/worldserver/worldserver.conf.dist
index 3109c92..1291b9c 100644
--- a/src/server/worldserver/worldserver.conf.dist
+++ b/src/server/worldserver/worldserver.conf.dist
@@ -2769,3 +2769,104 @@ LevelReq.Mail = 1
 
 #
 ###################################################################################################
+
+###################################################################################################
+# MOVEMENT ANTICHEAT
+#
+#    Anticheat.Movement.Enable
+#        Enable Movement Anticheat
+#        Default: 1 - on
+#                 0 - off
+
+Anticheat.Movement.Enable = 1
+
+#
+#    Anticheat.Movement.TeleportToPlaneAlarms
+#        maximum alarms before logging mode will be switched from debug to error (default 50, allowed 20 - 100)
+
+Anticheat.Movement.TeleportToPlaneAlarms = 50
+
+#
+#    Anticheat.Movement.MistimingDelta
+#        mistiming intelval between client and serverside (default 15000 ms, allowed 5000 - 50000 ms)
+
+Anticheat.Movement.MistimingDelta = 15000
+
+#
+#    Anticheat.Movement.MistimingAlarms
+#        mistiming alarms before logging mode will be switched from debug to error (default 200, allowed 100 - 500)
+
+Anticheat.Movement.MistimingAlarms = 200
+
+#    Anticheat.Movement.DisableOnVehicles
+#        Disable Movement Anticheat Checks if Player is riding a vehicle
+#        Default: 1 - on
+#                 0 - off
+
+Anticheat.Movement.DisableOnVehicles = 1
+
+#    Anticheat.Movement.Type.Mistiming
+#        Check if Player is out of synch (Mistiming)
+#        Default: 1 - on
+#                 0 - off
+
+Anticheat.Movement.Type.Mistiming = 1
+
+#    Anticheat.Movement.Type.TeleportToPlane
+#        Enable Teleport 2 Plane hacks detection
+#        Default: 1 - on
+#                 0 - off
+
+Anticheat.Movement.Type.TeleportToPlane = 1
+
+#    Anticheat.Movement.Type.Waterwalk
+#        Enable Waterwalk hack detection
+#        Default: 1 - on
+#                 0 - off
+
+Anticheat.Movement.Type.Waterwalk = 1
+
+#    Anticheat.Movement.Type.Flyhack
+#        Enable Flyhack detection
+#        Default: 1 - on
+#                 0 - off
+
+Anticheat.Movement.Type.Flyhack = 1
+
+#    Anticheat.Movement.Type.Mountainhack
+#        Enable Mountain/climbhack detection
+#        Default: 1 - on
+#                 0 - off
+
+Anticheat.Movement.Type.Mountainhack = 1
+
+#    Anticheat.Movement.Type.Speedhack
+#        Enable Speedhack detection
+#        Default: 1 - on
+#                 0 - off
+
+Anticheat.Movement.Type.Speedhack = 1
+
+#    Anticheat.Movement.Type.Teleport
+#        Enable Teleporthack detection
+#        Default: 1 - on
+#                 0 - off
+
+Anticheat.Movement.Type.Teleport = 1
+
+#    Anticheat.Movement.Type.MultiJump
+#        Enable MultiJump/AirJump detection
+#        Default: 1 - on
+#                 0 - off
+
+Anticheat.Movement.Type.MultiJump = 1
+
+#    Anticheat.Movement.Type.AntiGravity
+#        Enable AntiGravity detection
+#        Default: 1 - on
+#                 0 - off
+
+Anticheat.Movement.Type.AntiGravity = 1
+
+#
+###################################################################################################
-- 
1.7.3.1.msysgit.0

